<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Duplo Tower Stack</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  touch-action: none;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  font-family: 'Segoe UI', 'Arial Rounded MT Bold', Arial, sans-serif;
}
canvas {
  display: block;
  width: 100%; height: 100%;
}
#ui-overlay {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none;
  z-index: 10;
}
#score-display {
  position: absolute; top: 16px; left: 50%; transform: translateX(-50%);
  font-size: 28px; font-weight: 900;
  color: #fff; text-shadow: 2px 2px 0 #e74c3c, -1px -1px 0 #e74c3c, 1px -1px 0 #e74c3c, -1px 1px 0 #e74c3c;
  letter-spacing: 1px;
  z-index: 20;
}
#best-display {
  position: absolute; top: 52px; left: 50%; transform: translateX(-50%);
  font-size: 16px; font-weight: 700;
  color: #ffe082; text-shadow: 1px 1px 0 #bf360c;
  z-index: 20;
}
#start-screen, #game-over-screen {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  z-index: 100; pointer-events: auto;
}
#start-screen {
  background: linear-gradient(180deg, #4fc3f7 0%, #81d4fa 40%, #aed581 60%, #66bb6a 100%);
}
#game-over-screen {
  background: rgba(0,0,0,0.7);
  display: none;
}
.title {
  font-size: 42px; font-weight: 900;
  color: #fff; text-shadow: 3px 3px 0 #e74c3c, 6px 6px 0 rgba(0,0,0,0.15);
  margin-bottom: 8px; text-align: center;
  letter-spacing: 2px;
}
.subtitle {
  font-size: 18px; color: #fff9c4; text-shadow: 1px 1px 0 #bf360c;
  margin-bottom: 32px; font-weight: 700;
}
.btn {
  padding: 18px 48px; font-size: 24px; font-weight: 900;
  border: none; border-radius: 50px; cursor: pointer;
  pointer-events: auto;
  text-transform: uppercase; letter-spacing: 2px;
  box-shadow: 0 6px 0 rgba(0,0,0,0.25), 0 8px 24px rgba(0,0,0,0.2);
  transition: transform 0.1s, box-shadow 0.1s;
}
.btn:active {
  transform: translateY(3px);
  box-shadow: 0 3px 0 rgba(0,0,0,0.25), 0 4px 12px rgba(0,0,0,0.2);
}
.btn-play {
  background: linear-gradient(180deg, #ff7043, #e53935);
  color: #fff;
}
.btn-restart {
  background: linear-gradient(180deg, #66bb6a, #388e3c);
  color: #fff;
  margin-top: 20px;
}
.go-final-score {
  font-size: 72px; font-weight: 900;
  color: #ffeb3b; text-shadow: 3px 3px 0 #e65100;
  margin-bottom: 4px;
}
.go-label {
  font-size: 22px; color: #fff; font-weight: 700; margin-bottom: 6px;
}
.go-best {
  font-size: 16px; color: #ffe082; font-weight: 600; margin-bottom: 10px;
}
.scene-preview {
  margin-bottom: 24px;
  display: flex; gap: 6px; align-items: flex-end;
}
.preview-block {
  border-radius: 6px;
  box-shadow: 0 2px 0 rgba(0,0,0,0.2);
}
.tap-hint {
  font-size: 15px; color: rgba(255,255,255,0.85);
  margin-top: 16px; font-weight: 600;
  animation: pulse 1.5s ease-in-out infinite;
}
@keyframes pulse {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="ui-overlay">
  <div id="score-display"></div>
  <div id="best-display"></div>
</div>

<div id="start-screen">
  <div class="scene-preview">
    <div class="preview-block" style="width:30px;height:30px;background:#e53935;"></div>
    <div class="preview-block" style="width:30px;height:30px;background:#fdd835;"></div>
    <div class="preview-block" style="width:30px;height:60px;background:#43a047;"></div>
    <div class="preview-block" style="width:30px;height:45px;background:#1e88e5;"></div>
    <div class="preview-block" style="width:30px;height:30px;background:#fb8c00;"></div>
    <div class="preview-block" style="width:30px;height:75px;background:#8e24aa;"></div>
    <div class="preview-block" style="width:30px;height:45px;background:#e53935;"></div>
  </div>
  <div class="title">DUPLO TOWER</div>
  <div class="subtitle">Stack &rsquo;em up!</div>
  <button class="btn btn-play" id="btn-start">PLAY</button>
  <div class="tap-hint">Tap to drop blocks</div>
</div>

<div id="game-over-screen">
  <div class="go-label">YOUR TOWER</div>
  <div class="go-final-score" id="go-score">0</div>
  <div class="go-label">blocks tall!</div>
  <div class="go-best" id="go-best"></div>
  <button class="btn btn-restart" id="btn-restart">PLAY AGAIN</button>
</div>

<script>
// ─── Constants & State ───────────────────────────────────
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const BLOCK_COLORS = [
  '#e53935', '#fdd835', '#43a047', '#1e88e5',
  '#fb8c00', '#8e24aa', '#00acc1', '#f4511e',
  '#7cb342', '#d81b60'
];
const STUD_ROWS = 1;
const STUD_COLS = 3;

let W, H, BLOCK_W, BLOCK_H, GROUND_Y, BASE_Y;
let score, bestScore, blocks, currentBlock, gameState;
let cameraY, targetCameraY;
let particles, animals, clouds, flowers;

// ─── Responsive Sizing ──────────────────────────────────
function resize() {
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  BLOCK_W = Math.min(120, W * 0.28);
  BLOCK_H = BLOCK_W * 0.42;
  GROUND_Y = H - 80;
  BASE_Y = GROUND_Y - BLOCK_H;
}
window.addEventListener('resize', resize);
resize();

// ─── Helpers ─────────────────────────────────────────────
function rand(a, b) { return Math.random() * (b - a) + a; }
function randInt(a, b) { return Math.floor(rand(a, b + 1)); }
function pickColor(idx) { return BLOCK_COLORS[idx % BLOCK_COLORS.length]; }
function lerp(a, b, t) { return a + (b - a) * t; }
function darken(hex, f) {
  let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  r = Math.floor(r * f); g = Math.floor(g * f); b = Math.floor(b * f);
  return `rgb(${r},${g},${b})`;
}
function lighten(hex, f) {
  let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  r = Math.min(255, Math.floor(r + (255-r)*f));
  g = Math.min(255, Math.floor(g + (255-g)*f));
  b = Math.min(255, Math.floor(b + (255-b)*f));
  return `rgb(${r},${g},${b})`;
}

// ─── Drawing: Duplo Block ────────────────────────────────
function drawBlock(x, y, w, h, color, studsOnTop) {
  const r = 4;
  // Main body
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  ctx.fill();

  // Highlight (top)
  ctx.fillStyle = lighten(color, 0.25);
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h * 0.18);
  ctx.lineTo(x, y + h * 0.18);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  ctx.fill();

  // Shadow (bottom)
  ctx.fillStyle = darken(color, 0.78);
  ctx.beginPath();
  ctx.moveTo(x, y + h * 0.82);
  ctx.lineTo(x + w, y + h * 0.82);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.closePath();
  ctx.fill();

  // Outline
  ctx.strokeStyle = darken(color, 0.6);
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  ctx.stroke();

  // Studs on top
  if (studsOnTop) {
    const studR = Math.min(w * 0.1, h * 0.22);
    const studH = studR * 0.7;
    for (let c = 0; c < STUD_COLS; c++) {
      const sx = x + w * (c + 1) / (STUD_COLS + 1);
      const sy = y - studH;
      // Stud cylinder
      ctx.fillStyle = lighten(color, 0.12);
      ctx.beginPath();
      ctx.ellipse(sx, sy + studH, studR, studR * 0.45, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = color;
      ctx.fillRect(sx - studR, sy, studR * 2, studH);
      ctx.fillStyle = lighten(color, 0.32);
      ctx.beginPath();
      ctx.ellipse(sx, sy, studR, studR * 0.45, 0, 0, Math.PI * 2);
      ctx.fill();
      // Stud outline
      ctx.strokeStyle = darken(color, 0.6);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.ellipse(sx, sy, studR, studR * 0.45, 0, 0, Math.PI * 2);
      ctx.stroke();
    }
  }
}

// ─── Drawing: Animals ────────────────────────────────────
function drawCat(x, y, size, color) {
  const s = size;
  // Body
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.ellipse(x, y, s * 0.5, s * 0.35, 0, 0, Math.PI * 2);
  ctx.fill();
  // Head
  ctx.beginPath();
  ctx.arc(x + s * 0.45, y - s * 0.15, s * 0.28, 0, Math.PI * 2);
  ctx.fill();
  // Ears
  ctx.beginPath();
  ctx.moveTo(x + s * 0.3, y - s * 0.38);
  ctx.lineTo(x + s * 0.38, y - s * 0.6);
  ctx.lineTo(x + s * 0.5, y - s * 0.35);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + s * 0.5, y - s * 0.38);
  ctx.lineTo(x + s * 0.55, y - s * 0.58);
  ctx.lineTo(x + s * 0.65, y - s * 0.3);
  ctx.fill();
  // Eyes
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(x + s * 0.38, y - s * 0.2, s * 0.06, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + s * 0.52, y - s * 0.2, s * 0.06, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.arc(x + s * 0.39, y - s * 0.19, s * 0.03, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + s * 0.53, y - s * 0.19, s * 0.03, 0, Math.PI * 2);
  ctx.fill();
  // Tail
  ctx.strokeStyle = color;
  ctx.lineWidth = s * 0.08;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(x - s * 0.45, y - s * 0.05);
  ctx.quadraticCurveTo(x - s * 0.7, y - s * 0.5, x - s * 0.5, y - s * 0.6);
  ctx.stroke();
}

function drawElephant(x, y, size) {
  const s = size;
  ctx.fillStyle = '#78909c';
  // Body
  ctx.beginPath();
  ctx.ellipse(x, y, s * 0.55, s * 0.4, 0, 0, Math.PI * 2);
  ctx.fill();
  // Head
  ctx.beginPath();
  ctx.arc(x + s * 0.5, y - s * 0.1, s * 0.32, 0, Math.PI * 2);
  ctx.fill();
  // Ear
  ctx.fillStyle = '#90a4ae';
  ctx.beginPath();
  ctx.ellipse(x + s * 0.72, y - s * 0.05, s * 0.18, s * 0.28, 0.2, 0, Math.PI * 2);
  ctx.fill();
  // Trunk
  ctx.strokeStyle = '#78909c';
  ctx.lineWidth = s * 0.12;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(x + s * 0.75, y + s * 0.05);
  ctx.quadraticCurveTo(x + s * 0.95, y + s * 0.35, x + s * 0.8, y + s * 0.4);
  ctx.stroke();
  // Eye
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(x + s * 0.55, y - s * 0.18, s * 0.06, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.arc(x + s * 0.56, y - s * 0.17, s * 0.03, 0, Math.PI * 2);
  ctx.fill();
  // Legs
  ctx.fillStyle = '#78909c';
  [-0.25, -0.05, 0.15, 0.3].forEach(off => {
    ctx.fillRect(x + s * off - s * 0.06, y + s * 0.28, s * 0.12, s * 0.2);
  });
}

function drawTurtle(x, y, size) {
  const s = size;
  // Shell
  ctx.fillStyle = '#66bb6a';
  ctx.beginPath();
  ctx.ellipse(x, y - s * 0.08, s * 0.4, s * 0.28, 0, Math.PI, 0);
  ctx.fill();
  // Shell pattern
  ctx.fillStyle = '#43a047';
  ctx.beginPath();
  ctx.ellipse(x, y - s * 0.14, s * 0.22, s * 0.15, 0, Math.PI, 0);
  ctx.fill();
  // Body under shell
  ctx.fillStyle = '#a5d6a7';
  ctx.beginPath();
  ctx.ellipse(x, y + s * 0.02, s * 0.42, s * 0.12, 0, 0, Math.PI);
  ctx.fill();
  // Head
  ctx.fillStyle = '#81c784';
  ctx.beginPath();
  ctx.arc(x + s * 0.4, y, s * 0.12, 0, Math.PI * 2);
  ctx.fill();
  // Eye
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.arc(x + s * 0.44, y - s * 0.03, s * 0.025, 0, Math.PI * 2);
  ctx.fill();
  // Legs
  ctx.fillStyle = '#81c784';
  [[-0.28, 0.1], [-0.1, 0.12], [0.1, 0.12], [0.28, 0.1]].forEach(([ox, oy]) => {
    ctx.beginPath();
    ctx.ellipse(x + s * ox, y + s * oy, s * 0.07, s * 0.05, 0, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawFlower(x, y, size, color) {
  const s = size;
  // Stem
  ctx.strokeStyle = '#43a047';
  ctx.lineWidth = s * 0.08;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x, y + s * 0.6);
  ctx.stroke();
  // Leaf
  ctx.fillStyle = '#66bb6a';
  ctx.beginPath();
  ctx.ellipse(x + s * 0.12, y + s * 0.35, s * 0.1, s * 0.05, 0.5, 0, Math.PI * 2);
  ctx.fill();
  // Petals
  ctx.fillStyle = color;
  for (let i = 0; i < 5; i++) {
    const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
    ctx.beginPath();
    ctx.ellipse(x + Math.cos(a) * s * 0.13, y + Math.sin(a) * s * 0.13, s * 0.1, s * 0.06, a, 0, Math.PI * 2);
    ctx.fill();
  }
  // Center
  ctx.fillStyle = '#fdd835';
  ctx.beginPath();
  ctx.arc(x, y, s * 0.07, 0, Math.PI * 2);
  ctx.fill();
}

// ─── Drawing: Cloud ──────────────────────────────────────
function drawCloud(x, y, size) {
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  const s = size;
  ctx.beginPath();
  ctx.arc(x, y, s * 0.3, 0, Math.PI * 2);
  ctx.arc(x + s * 0.25, y - s * 0.12, s * 0.25, 0, Math.PI * 2);
  ctx.arc(x + s * 0.5, y, s * 0.28, 0, Math.PI * 2);
  ctx.arc(x + s * 0.22, y + s * 0.08, s * 0.22, 0, Math.PI * 2);
  ctx.fill();
}

// ─── Drawing: Duplo Figure ───────────────────────────────
function drawFigure(x, y, size, bodyColor, skinColor) {
  const s = size;
  // Legs
  ctx.fillStyle = bodyColor;
  ctx.fillRect(x - s * 0.15, y + s * 0.3, s * 0.12, s * 0.2);
  ctx.fillRect(x + s * 0.03, y + s * 0.3, s * 0.12, s * 0.2);
  // Body
  ctx.fillStyle = bodyColor;
  ctx.beginPath();
  ctx.moveTo(x - s * 0.2, y + s * 0.3);
  ctx.lineTo(x + s * 0.2, y + s * 0.3);
  ctx.lineTo(x + s * 0.17, y - s * 0.05);
  ctx.lineTo(x - s * 0.17, y - s * 0.05);
  ctx.closePath();
  ctx.fill();
  // Head
  ctx.fillStyle = skinColor;
  ctx.beginPath();
  ctx.arc(x, y - s * 0.2, s * 0.16, 0, Math.PI * 2);
  ctx.fill();
  // Eyes
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.arc(x - s * 0.06, y - s * 0.22, s * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + s * 0.06, y - s * 0.22, s * 0.025, 0, Math.PI * 2);
  ctx.fill();
  // Smile
  ctx.strokeStyle = '#222';
  ctx.lineWidth = s * 0.02;
  ctx.beginPath();
  ctx.arc(x, y - s * 0.17, s * 0.07, 0.2, Math.PI - 0.2);
  ctx.stroke();
  // Hair / hat bump
  ctx.fillStyle = darken(bodyColor, 0.7);
  ctx.beginPath();
  ctx.ellipse(x, y - s * 0.36, s * 0.12, s * 0.04, 0, 0, Math.PI * 2);
  ctx.fill();
}

// ─── Particles ───────────────────────────────────────────
function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: rand(-3, 3),
      vy: rand(-5, -1),
      r: rand(2, 5),
      color: Math.random() > 0.5 ? color : lighten(color, 0.4),
      life: 1,
      decay: rand(0.015, 0.035)
    });
  }
}

function spawnPerfectParticles(x, y) {
  const cols = ['#fdd835', '#ff7043', '#66bb6a', '#42a5f5', '#ab47bc'];
  for (let i = 0; i < 20; i++) {
    particles.push({
      x, y,
      vx: rand(-5, 5),
      vy: rand(-8, -2),
      r: rand(3, 7),
      color: cols[randInt(0, cols.length - 1)],
      life: 1,
      decay: rand(0.01, 0.025)
    });
  }
}

// ─── Scene Elements ──────────────────────────────────────
function initScene() {
  animals = [
    { type: 'cat', x: W * 0.1, size: 28, color: '#fb8c00' },
    { type: 'cat', x: W * 0.85, size: 24, color: '#78909c' },
    { type: 'elephant', x: W * 0.2, size: 32 },
    { type: 'turtle', x: W * 0.78, size: 26 },
  ];
  clouds = [];
  for (let i = 0; i < 4; i++) {
    clouds.push({ x: rand(0, W), y: rand(30, H * 0.25), size: rand(40, 80), speed: rand(0.15, 0.4) });
  }
  flowers = [];
  const flowerColors = ['#e53935', '#fdd835', '#ab47bc', '#f06292', '#ff7043'];
  for (let i = 0; i < 8; i++) {
    let fx = rand(10, W - 10);
    // Keep flowers away from center tower area
    if (Math.abs(fx - W / 2) < BLOCK_W * 0.8) fx += (fx < W / 2 ? -1 : 1) * BLOCK_W;
    flowers.push({ x: fx, y: GROUND_Y, size: rand(14, 22), color: flowerColors[randInt(0, flowerColors.length - 1)] });
  }
}

// ─── Drawing: House ──────────────────────────────────────
function drawHouse(x, y, size) {
  const s = size;
  // Walls
  ctx.fillStyle = '#e53935';
  ctx.fillRect(x - s * 0.4, y - s * 0.4, s * 0.8, s * 0.5);
  // Roof
  ctx.fillStyle = '#c62828';
  ctx.beginPath();
  ctx.moveTo(x - s * 0.5, y - s * 0.4);
  ctx.lineTo(x, y - s * 0.75);
  ctx.lineTo(x + s * 0.5, y - s * 0.4);
  ctx.closePath();
  ctx.fill();
  // Door
  ctx.fillStyle = '#fdd835';
  ctx.fillRect(x - s * 0.08, y - s * 0.15, s * 0.16, s * 0.25);
  // Window
  ctx.fillStyle = '#bbdefb';
  ctx.fillRect(x + s * 0.12, y - s * 0.32, s * 0.14, s * 0.12);
  ctx.fillRect(x - s * 0.3, y - s * 0.32, s * 0.14, s * 0.12);
  // Window cross
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1.5;
  [x + s * 0.19, x - s * 0.23].forEach(wx => {
    ctx.beginPath();
    ctx.moveTo(wx, y - s * 0.32);
    ctx.lineTo(wx, y - s * 0.2);
    ctx.moveTo(wx - s * 0.07, y - s * 0.26);
    ctx.lineTo(wx + s * 0.07, y - s * 0.26);
    ctx.stroke();
  });
}

// ─── Game Logic ──────────────────────────────────────────
function initGame() {
  score = 0;
  blocks = [];
  particles = [];
  cameraY = 0;
  targetCameraY = 0;
  bestScore = parseInt(localStorage.getItem('duploTowerBest') || '0');
  initScene();
  spawnBlock();
  gameState = 'playing';
  document.getElementById('score-display').textContent = 'Blocks: 0';
  document.getElementById('best-display').textContent = bestScore > 0 ? `Best: ${bestScore}` : '';
  document.getElementById('game-over-screen').style.display = 'none';
}

function spawnBlock() {
  const bw = BLOCK_W;
  const stackTop = blocks.length === 0 ? BASE_Y : blocks[blocks.length - 1].y - BLOCK_H;
  // If there are previous blocks, match width to the top of stack
  const prevBlock = blocks.length > 0 ? blocks[blocks.length - 1] : null;
  const actualW = prevBlock ? prevBlock.w : bw;

  currentBlock = {
    x: -actualW, // start off-screen left
    y: stackTop,
    w: actualW,
    h: BLOCK_H,
    color: pickColor(blocks.length),
    dir: 1,
    speed: Math.min(2.5 + blocks.length * 0.18, 7),
    settled: false
  };
}

function dropBlock() {
  if (!currentBlock || currentBlock.settled) return;
  currentBlock.settled = true;

  if (blocks.length === 0) {
    // First block - just place it centered
    currentBlock.x = W / 2 - currentBlock.w / 2;
    blocks.push(currentBlock);
    score = 1;
    spawnParticles(currentBlock.x + currentBlock.w / 2, currentBlock.y, currentBlock.color, 8);
  } else {
    const prev = blocks[blocks.length - 1];
    const overlap = Math.min(currentBlock.x + currentBlock.w, prev.x + prev.w) - Math.max(currentBlock.x, prev.x);

    if (overlap <= 0) {
      // Missed entirely - game over
      gameOver();
      return;
    }

    // Trim the block to the overlapping section
    const newX = Math.max(currentBlock.x, prev.x);
    const newW = overlap;

    // Check for "perfect" placement (nearly full overlap)
    const perfectThreshold = prev.w * 0.92;
    if (overlap >= perfectThreshold) {
      // Perfect! Keep full width of previous block
      currentBlock.x = prev.x;
      currentBlock.w = prev.w;
      spawnPerfectParticles(currentBlock.x + currentBlock.w / 2, currentBlock.y);
    } else {
      // Slice off the overhanging part — spawn a falling piece
      const overhangDir = currentBlock.x < prev.x ? -1 : 1;
      const overhangW = currentBlock.w - overlap;
      const overhangX = overhangDir < 0 ? currentBlock.x : newX + newW;
      spawnFallingPiece(overhangX, currentBlock.y, overhangW, currentBlock.h, currentBlock.color, overhangDir);

      currentBlock.x = newX;
      currentBlock.w = newW;
      spawnParticles(currentBlock.x + currentBlock.w / 2, currentBlock.y, currentBlock.color, 6);
    }

    blocks.push(currentBlock);
    score = blocks.length;

    // Check if block is too narrow — game over
    if (currentBlock.w < BLOCK_W * 0.08) {
      gameOver();
      return;
    }
  }

  // Update camera
  const towerTop = blocks[blocks.length - 1].y;
  const viewTarget = H * 0.45;
  if (towerTop - cameraY < viewTarget) {
    targetCameraY = towerTop - viewTarget;
  }

  updateUI();
  spawnBlock();
}

let fallingPieces = [];
function spawnFallingPiece(x, y, w, h, color, dir) {
  fallingPieces.push({ x, y, w, h, color, vy: 0, vx: dir * 1.5, rot: 0, vrot: dir * 0.05 });
}

function gameOver() {
  gameState = 'over';
  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem('duploTowerBest', bestScore);
  }
  document.getElementById('go-score').textContent = score;
  document.getElementById('go-best').textContent = `Best: ${bestScore}`;
  document.getElementById('game-over-screen').style.display = 'flex';
  document.getElementById('score-display').textContent = '';
  document.getElementById('best-display').textContent = '';
}

function updateUI() {
  document.getElementById('score-display').textContent = `Blocks: ${score}`;
  document.getElementById('best-display').textContent = bestScore > 0 ? `Best: ${bestScore}` : '';
}

// ─── Main Loop ───────────────────────────────────────────
function update() {
  // Camera
  cameraY = lerp(cameraY, targetCameraY, 0.08);

  // Current block movement
  if (gameState === 'playing' && currentBlock && !currentBlock.settled) {
    currentBlock.x += currentBlock.dir * currentBlock.speed;
    if (currentBlock.x + currentBlock.w > W + 20) currentBlock.dir = -1;
    if (currentBlock.x < -20) currentBlock.dir = 1;
  }

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.15;
    p.life -= p.decay;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Falling pieces
  for (let i = fallingPieces.length - 1; i >= 0; i--) {
    const f = fallingPieces[i];
    f.vy += 0.4;
    f.y += f.vy;
    f.x += f.vx;
    f.rot += f.vrot;
    if (f.y > H + 100 - cameraY) fallingPieces.splice(i, 1);
  }

  // Clouds
  clouds.forEach(c => {
    c.x += c.speed;
    if (c.x > W + c.size) c.x = -c.size * 2;
  });
}

function draw() {
  ctx.clearRect(0, 0, W, H);

  // Sky gradient
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  skyGrad.addColorStop(0, '#4fc3f7');
  skyGrad.addColorStop(0.6, '#81d4fa');
  skyGrad.addColorStop(1, '#b3e5fc');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);

  // Clouds (fixed, behind everything in sky)
  clouds.forEach(c => drawCloud(c.x, c.y, c.size));

  ctx.save();
  ctx.translate(0, -cameraY);

  // Ground
  ctx.fillStyle = '#66bb6a';
  ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y + 200);
  // Ground texture
  ctx.fillStyle = '#5cb860';
  for (let gx = 0; gx < W; gx += 18) {
    ctx.fillRect(gx, GROUND_Y, 9, 4);
  }

  // Green baseplate (under tower)
  const bpW = BLOCK_W * 1.6;
  ctx.fillStyle = '#43a047';
  ctx.fillRect(W / 2 - bpW / 2, GROUND_Y - 6, bpW, 10);
  ctx.strokeStyle = '#388e3c';
  ctx.lineWidth = 1;
  ctx.strokeRect(W / 2 - bpW / 2, GROUND_Y - 6, bpW, 10);
  // Baseplate studs
  ctx.fillStyle = '#4caf50';
  for (let i = 0; i < 6; i++) {
    const sx = W / 2 - bpW / 2 + bpW * (i + 0.5) / 6;
    ctx.beginPath();
    ctx.arc(sx, GROUND_Y - 7, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  // House (right side)
  drawHouse(W * 0.84, GROUND_Y - 5, 65);

  // Flowers
  flowers.forEach(f => drawFlower(f.x, f.y - 4, f.size, f.color));

  // Animals
  animals.forEach(a => {
    const ay = GROUND_Y - 2;
    if (a.type === 'cat') drawCat(a.x, ay, a.size, a.color);
    else if (a.type === 'elephant') drawElephant(a.x, ay, a.size);
    else if (a.type === 'turtle') drawTurtle(a.x, ay, a.size);
  });

  // Figures
  drawFigure(W * 0.35, GROUND_Y - 12, 40, '#1e88e5', '#ffcc80');
  drawFigure(W * 0.62, GROUND_Y - 12, 38, '#e53935', '#ffcc80');

  // Stacked blocks
  blocks.forEach((b, i) => {
    const isTop = (i === blocks.length - 1) && (gameState === 'playing');
    drawBlock(b.x, b.y, b.w, b.h, b.color, isTop);
  });

  // Current moving block
  if (gameState === 'playing' && currentBlock && !currentBlock.settled) {
    drawBlock(currentBlock.x, currentBlock.y, currentBlock.w, currentBlock.h, currentBlock.color, true);

    // Drop guide line
    ctx.setLineDash([4, 4]);
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(currentBlock.x + currentBlock.w / 2, currentBlock.y + currentBlock.h);
    ctx.lineTo(currentBlock.x + currentBlock.w / 2, GROUND_Y);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Falling pieces
  fallingPieces.forEach(f => {
    ctx.save();
    ctx.translate(f.x + f.w / 2, f.y + f.h / 2);
    ctx.rotate(f.rot);
    ctx.globalAlpha = 0.8;
    drawBlock(-f.w / 2, -f.h / 2, f.w, f.h, f.color, false);
    ctx.globalAlpha = 1;
    ctx.restore();
  });

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  ctx.restore();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

// ─── Input ───────────────────────────────────────────────
function handleTap(e) {
  e.preventDefault();
  if (gameState === 'playing') {
    dropBlock();
  }
}

canvas.addEventListener('touchstart', handleTap, { passive: false });
canvas.addEventListener('mousedown', handleTap);
window.addEventListener('keydown', e => {
  if (e.code === 'Space' && gameState === 'playing') {
    e.preventDefault();
    dropBlock();
  }
});

document.getElementById('btn-start').addEventListener('click', () => {
  document.getElementById('start-screen').style.display = 'none';
  initGame();
  loop();
});
document.getElementById('btn-restart').addEventListener('click', () => {
  fallingPieces = [];
  initGame();
});
</script>
</body>
</html>
